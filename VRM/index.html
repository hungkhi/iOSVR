<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Random VRM Model & Animation Viewer</title>
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
        <style>
html, body {
    height: 100%;
    min-height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

body {
    background-image: url('https://img.freepik.com/free-photo/anime-style-cozy-home-interior-with-furnishings_23-2151176377.jpg');
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
}

/* Smooth background crossfade overlay */
#bgFadeOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    opacity: 0;
    transition: opacity 400ms ease;
    z-index: 0; /* below canvas (z-index:1), above body background */
    pointer-events: none;
}

canvas {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    /* Lift the rendered scene visually without changing model/camera coordinates */
    margin-top: -40px; /* adjust as desired */
    z-index: 1;
}


#divInfo {
    position: fixed;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    margin: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    font-family: Arial, sans-serif;
    z-index: 1000;
    display: none;
}

#currentFiles {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #ccc;
    font-size: 14px;
}

.file-info {
    margin: 5px 0;
    color: #555;
}

.file-name {
    font-weight: bold;
    color: #333;
}

#reloadBtn, #nextAnimBtn {
    padding: 8px 16px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease;
}

#reloadBtn:hover, #nextAnimBtn:hover {
    background: #5a67d8;
}

#nextAnimBtn {
    background: #48bb78;
}

#nextAnimBtn:hover {
    background: #38a169;
}

#reloadBtn:disabled, #nextAnimBtn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

#nextAnimBtn:disabled:hover {
    background: #48bb78;
}

.lil-gui {
    display: none !important;
}
/* Floating action buttons (right side) */
/* swift overlay buttons will replace web buttons */


/* Loading overlay and blur */
#loadingOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    background: rgba(0,0,0,0.25);
    z-index: 1001;
    font-family: Arial, sans-serif;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.6);
}
#loadingText {
    margin-top: 12px;
    font-size: 16px;
}
.loading-blur {
    filter: blur(6px) saturate(0.9) brightness(0.95);
    transition: filter 0.2s ease;
}
        </style>
    </head>

    <body>
        <div id="bgFadeOverlay"></div>
        <div id="loadingOverlay">
            <svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg" stroke="#fff">
                <g fill="none" fill-rule="evenodd" stroke-width="4">
                    <circle cx="22" cy="22" r="18" stroke-opacity="0.3" />
                    <path d="M40 22c0-9.94-8.06-18-18-18" stroke="#fff">
                        <animateTransform attributeName="transform" type="rotate" from="0 22 22" to="360 22 22" dur="1s" repeatCount="indefinite" />
                    </path>
                </g>
            </svg>
            <div id="loadingText">Loading... 0%</div>
        </div>
        <div id="divInfo">
            <strong>Random VRM & Animation Loader</strong><br>
            <span style="font-size: 12px; color: #666;">Drag and drop to override</span>
            <div id="currentFiles">
                <div class="file-info">Model: <span id="currentModel" class="file-name">Loading...</span></div>
                <div class="file-info">Animation: <span id="currentAnimation" class="file-name">Loading...</span></div>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 10px;">
                <button id="reloadBtn" onclick="loadRandomFiles()">Load New Random</button>
                <button id="nextAnimBtn" onclick="loadNextAnimation()">Next Animation</button>
            </div>
        </div>

        <!-- Swift overlay buttons will be added in native UI -->

        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/",
                    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
                }
            }
        </script>

        <script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
import GUI from 'three/addons/libs/lil-gui.module.min.js';

// === Inlined from config.js ===
const mixamoVRMRigMap = {"mixamorigHips":"hips","mixamorigSpine":"spine","mixamorigSpine1":"chest","mixamorigSpine2":"upperChest","mixamorigNeck":"neck","mixamorigHead":"head","mixamorigLeftShoulder":"leftShoulder","mixamorigLeftArm":"leftUpperArm","mixamorigLeftForeArm":"leftLowerArm","mixamorigLeftHand":"leftHand","mixamorigLeftHandThumb1":"leftThumbMetacarpal","mixamorigLeftHandThumb2":"leftThumbProximal","mixamorigLeftHandThumb3":"leftThumbDistal","mixamorigLeftHandIndex1":"leftIndexProximal","mixamorigLeftHandIndex2":"leftIndexIntermediate","mixamorigLeftHandIndex3":"leftIndexDistal","mixamorigLeftHandMiddle1":"leftMiddleProximal","mixamorigLeftHandMiddle2":"leftMiddleIntermediate","mixamorigLeftHandMiddle3":"leftMiddleDistal","mixamorigLeftHandRing1":"leftRingProximal","mixamorigLeftHandRing2":"leftRingIntermediate","mixamorigLeftHandRing3":"leftRingDistal","mixamorigLeftHandPinky1":"leftLittleProximal","mixamorigLeftHandPinky2":"leftLittleIntermediate","mixamorigLeftHandPinky3":"leftLittleDistal","mixamorigRightShoulder":"rightShoulder","mixamorigRightArm":"rightUpperArm","mixamorigRightForeArm":"rightLowerArm","mixamorigRightHand":"rightHand","mixamorigRightHandThumb1":"rightThumbMetacarpal","mixamorigRightHandThumb2":"rightThumbProximal","mixamorigRightHandThumb3":"rightThumbDistal","mixamorigRightHandIndex1":"rightIndexProximal","mixamorigRightHandIndex2":"rightIndexIntermediate","mixamorigRightHandIndex3":"rightIndexDistal","mixamorigRightHandMiddle1":"rightMiddleProximal","mixamorigRightHandMiddle2":"rightMiddleIntermediate","mixamorigRightHandMiddle3":"rightMiddleDistal","mixamorigRightHandRing1":"rightRingProximal","mixamorigRightHandRing2":"rightRingIntermediate","mixamorigRightHandRing3":"rightRingDistal","mixamorigRightHandPinky1":"rightLittleProximal","mixamorigRightHandPinky2":"rightLittleIntermediate","mixamorigRightHandPinky3":"rightLittleDistal","mixamorigLeftUpLeg":"leftUpperLeg","mixamorigLeftLeg":"leftLowerLeg","mixamorigLeftFoot":"leftFoot","mixamorigLeftToeBase":"leftToes","mixamorigRightUpLeg":"rightUpperLeg","mixamorigRightLeg":"rightLowerLeg","mixamorigRightFoot":"rightFoot","mixamorigRightToeBase":"rightToes"};
const genericVRMRigMap = {"Hips":"hips","Spine":"spine","Chest":"chest","UpperChest":"upperChest","Neck":"neck","Head":"head","LeftShoulder":"leftShoulder","LeftUpperArm":"leftUpperArm","LeftLowerArm":"leftLowerArm","LeftHand":"leftHand","RightShoulder":"rightShoulder","RightUpperArm":"rightUpperArm","RightLowerArm":"rightLowerArm","RightHand":"rightHand","LeftUpperLeg":"leftUpperLeg","LeftLowerLeg":"leftLowerLeg","LeftFoot":"leftFoot","LeftToes":"leftToes","RightUpperLeg":"rightUpperLeg","RightLowerLeg":"rightLowerLeg","RightFoot":"rightFoot","RightToes":"rightToes","hips":"hips","spine":"spine","chest":"chest","upper_chest":"upperChest","neck":"neck","head":"head","shoulder.L":"leftShoulder","upper_arm.L":"leftUpperArm","forearm.L":"leftLowerArm","hand.L":"leftHand","shoulder.R":"rightShoulder","upper_arm.R":"rightUpperArm","forearm.R":"rightLowerArm","hand.R":"rightHand","thigh.L":"leftUpperLeg","shin.L":"leftLowerLeg","foot.L":"leftFoot","toe.L":"leftToes","thigh.R":"rightUpperLeg","shin.R":"rightLowerLeg","foot.R":"rightFoot","toe.R":"rightToes"};
const combinedRigMap = { ...genericVRMRigMap, ...mixamoVRMRigMap };
const vrmFiles = ["0001_01 2.vrm","0001_01 3.vrm","0001_02 2.vrm","0001_02 3.vrm","0001_02.vrm","0001_03 2.vrm","0001_03.vrm","0001_04 2.vrm","0001_04.vrm","0001_05 2.vrm","0001_05.vrm","0001_06 2.vrm","0001_06.vrm","0001_07 2.vrm","0001_07 3.vrm","0001_07.vrm 2","0001_07.vrm","0001_08 2.vrm","0001_08 3.vrm","0001_08.vrm 2","0001_08.vrm","0001_09 2.vrm","0001_09.vrm","0001_10.vrm"];
const fbxFiles = ["Angry.fbx","Bashful.fbx","Blow A Kiss.fbx","Booty Hip Hop Dance.fbx","Cross Jumps.fbx","Hand Raising.fbx","Happy.fbx","Hip Hop Dancing.fbx","Idle Stand.fbx","Jumping Jacks.fbx","Quick Steps.fbx","Rumba Dancing.fbx","Snake Hip Hop Dance.fbx","Standing Arguing.fbx","Standing Greeting.fbx","Step Hip Hop Dance.fbx","Talking.fbx","Taunt.fbx","Thinking.fbx","Threatening.fbx"];
const VRM_BASE_URL = 'https://n6n.top/Model/';
const FBX_BASE_URL = 'https://n6n.top/Anim/';
const BGM_URL = 'https://pub-14a49f54cd754145a7362876730a1a52.r2.dev/sensual-escape-139637.mp3';
const namePatterns = {hips:/hip/i,spine:/spine/i,chest:/chest|spine1/i,upperChest:/upperchest|spine2/i,neck:/neck/i,head:/head/i,leftShoulder:/l(eft)?[-_\s]?shoulder/i,leftUpperArm:/l(eft)?[-_\s]?(upper)?[-_\s]?arm/i,leftLowerArm:/l(eft)?[-_\s]?(lower|fore)[-_\s]?arm/i,leftHand:/l(eft)?[-_\s]?hand/i,rightShoulder:/r(ight)?[-_\s]?shoulder/i,rightUpperArm:/r(ight)?[-_\s]?(upper)?[-_\s]?arm/i,rightLowerArm:/r(ight)?[-_\s]?(lower|fore)[-_\s]?arm/i,rightHand:/r(ight)?[-_\s]?hand/i,leftUpperLeg:/l(eft)?[-_\s]?(upper|up)[-_\s]?leg|l(eft)?[-_\s]?thigh/i,leftLowerLeg:/l(eft)?[-_\s]?(lower)?[-_\s]?leg|l(eft)?[-_\s]?(shin|calf)/i,leftFoot:/l(eft)?[-_\s]?foot/i,leftToes:/l(eft)?[-_\s]?(toe|toebase)/i,rightUpperLeg:/r(ight)?[-_\s]?(upper|up)[-_\s]?leg|r(ight)?[-_\s]?thigh/i,rightLowerLeg:/r(ight)?[-_\s]?(lower)?[-_\s]?leg|r(ight)?[-_\s]?(shin|calf)/i,rightFoot:/r(ight)?[-_\s]?foot/i,rightToes:/r(ight)?[-_\s]?(toe|toebase)/i};
// === End inlined config ===

// === Background preloading and cache ===
const modelObjectURLCache = new Map(); // name -> Promise<objectURL>
const animObjectURLCache = new Map();  // name -> Promise<objectURL>
let preloadingStarted = false;

// Splash gating: wait for first animation and background to be applied
let initialAnimationApplied = false;
let initialBackgroundReady = false;
let progress100At = null; // timestamp when progress reached 100%
let overlayHiddenAt = null; // timestamp when loading overlay was hidden
let notifyTimer = null;
function notifyInitialReadyIfDone() {
    try {
        if (!(initialAnimationApplied && initialBackgroundReady)) return;
        const now = performance.now();
        const t100 = progress100At ?? now;
        const thide = overlayHiddenAt ?? now;
        const target = Math.max(t100, thide) + 1000; // 1s after 100% + overlay hidden
        const waitMs = target - now;
        if (waitMs <= 0) {
            window.webkit?.messageHandlers?.loading?.postMessage('initialReady');
        } else {
            if (notifyTimer) { clearTimeout(notifyTimer); }
            notifyTimer = setTimeout(() => { try { window.webkit?.messageHandlers?.loading?.postMessage('initialReady'); } catch {} }, waitMs);
        }
    } catch {}
}

function fetchAndCacheObjectURL(name, baseUrl, cacheMap) {
    if (cacheMap.has(name)) return cacheMap.get(name);
    const url = baseUrl + encodeURIComponent(name);
    const promise = fetch(url, { mode: 'cors' })
        .then(r => {
            if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + name);
            return r.blob();
        })
        .then(blob => URL.createObjectURL(blob))
        .catch(err => {
            cacheMap.delete(name);
            throw err;
        });
    cacheMap.set(name, promise);
    return promise;
}

async function withConcurrency(names, worker, concurrency = 3) {
    const queue = names.slice();
    const running = [];
    const results = [];
    while (queue.length > 0 || running.length > 0) {
        while (running.length < concurrency && queue.length > 0) {
            const name = queue.shift();
            const p = Promise.resolve().then(() => worker(name))
                .then(res => ({ status: 'fulfilled', value: res, name }))
                .catch(err => ({ status: 'rejected', reason: err, name }));
            running.push(p);
        }
        const settled = await Promise.race(running.map((p, i) => p.then(v => ({ v, i }))));
        running.splice(settled.i, 1);
        results.push(settled.v);
    }
    return results;
}

async function startBackgroundPreloading(excludeModelName = null, excludeAnimationName = null) {
    if (preloadingStarted) return;
    preloadingStarted = true;
    try {
        const modelNames = vrmFiles.filter(n => n !== excludeModelName);
        const animNames = fbxFiles.filter(n => n !== excludeAnimationName);
        // Kick off both in parallel
        await Promise.all([
            withConcurrency(modelNames, (name) => fetchAndCacheObjectURL(name, VRM_BASE_URL, modelObjectURLCache), 2),
            withConcurrency(animNames, (name) => fetchAndCacheObjectURL(name, FBX_BASE_URL, animObjectURLCache), 3)
        ]);
        /* preloading completed */
    } catch (e) {
        /* background preloading finished with some errors */
    }
}

async function getModelURL(name) {
    if (!name) return null;
    if (modelObjectURLCache.has(name)) {
        try { return await modelObjectURLCache.get(name); } catch { /* fallthrough */ }
    }
    // If not cached, return remote URL and also start caching in background
    const remote = VRM_BASE_URL + encodeURIComponent(name);
    fetchAndCacheObjectURL(name, VRM_BASE_URL, modelObjectURLCache);
    return remote;
}

async function getAnimationURL(name) {
    if (!name) return null;
    if (animObjectURLCache.has(name)) {
        try { return await animObjectURLCache.get(name); } catch { /* fallthrough */ }
    }
    const remote = FBX_BASE_URL + encodeURIComponent(name);
    fetchAndCacheObjectURL(name, FBX_BASE_URL, animObjectURLCache);
    return remote;
}

function safeFileNameFromUrl(url) {
    try {
        // Handle blob: URLs and http(s): URLs
        if (!url) return null;
        const last = url.split('/').pop() || '';
        try { return decodeURIComponent(last); } catch { return last; }
    } catch {
        return null;
    }
}

function findBoneMapping(boneName) {
    if (combinedRigMap[boneName]) {
        return combinedRigMap[boneName];
    }
    const lowerName = boneName.toLowerCase();
    for (const [key, value] of Object.entries(combinedRigMap)) {
        if (key.toLowerCase() === lowerName) {
            return value;
        }
    }
    for (const [vrmBone, pattern] of Object.entries(namePatterns)) {
        if (pattern.test(boneName)) {
            return vrmBone;
        }
    }
    return null;
}

function loadHumanoidAnimation( url, vrm ) {
    const loader = new FBXLoader();
    loader.crossOrigin = 'anonymous';
    return loader.loadAsync( url ).then( ( asset ) => {
        let clip = THREE.AnimationClip.findByName( asset.animations, 'mixamo.com' );
        if (!clip && asset.animations.length > 0) {
            clip = asset.animations[0];
        }
        if (!clip) {
            throw new Error('No animation found in FBX file');
        }
        const tracks = [];
        const restRotationInverse = new THREE.Quaternion();
        const parentRestWorldRotation = new THREE.Quaternion();
        const _quatA = new THREE.Quaternion();
        const _vec3 = new THREE.Vector3();
        let hipsNode = null;
        asset.traverse((node) => {
            if (!hipsNode) {
                const vrmBoneName = findBoneMapping(node.name);
                if (vrmBoneName === 'hips') {
                    hipsNode = node;
                }
            }
        });
        let hipsPositionScale = 1.0;
        if (hipsNode) {
            const motionHipsHeight = hipsNode.position.y;
            const vrmHipsY = vrm.humanoid?.getNormalizedBoneNode( 'hips' )?.getWorldPosition( _vec3 ).y || 1;
            const vrmRootY = vrm.scene.getWorldPosition( _vec3 ).y;
            const vrmHipsHeight = Math.abs( vrmHipsY - vrmRootY );
            if (motionHipsHeight > 0) {
                hipsPositionScale = vrmHipsHeight / motionHipsHeight;
            }
        }
        clip.tracks.forEach( ( track ) => {
            const trackSplitted = track.name.split( '.' );
            const rigBoneName = trackSplitted[ 0 ];
            const vrmBoneName = findBoneMapping( rigBoneName );
            if (!vrmBoneName) {
                return;
            }
            const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode( vrmBoneName )?.name;
            const rigNode = asset.getObjectByName( rigBoneName );
            if ( vrmNodeName != null && rigNode ) {
                const propertyName = trackSplitted[ 1 ];
                rigNode.getWorldQuaternion( restRotationInverse ).invert();
                rigNode.parent.getWorldQuaternion( parentRestWorldRotation );
                if ( track instanceof THREE.QuaternionKeyframeTrack ) {
                    for ( let i = 0; i < track.values.length; i += 4 ) {
                        const flatQuaternion = track.values.slice( i, i + 4 );
                        _quatA.fromArray( flatQuaternion );
                        _quatA.premultiply( parentRestWorldRotation ).multiply( restRotationInverse );
                        _quatA.toArray( flatQuaternion );
                        flatQuaternion.forEach( ( v, index ) => {
                            track.values[ index + i ] = v;
                        } );
                    }
                    tracks.push(
                        new THREE.QuaternionKeyframeTrack(
                            `${ vrmNodeName }.${ propertyName }`,
                            track.times,
                            track.values.map( ( v, i ) => ( vrm.meta?.metaVersion === '0' && i % 2 === 0 ? - v : v ) ),
                        ),
                    );
                } else if ( track instanceof THREE.VectorKeyframeTrack ) {
                    const value = track.values.map( ( v, i ) => ( vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? - v : v ) * hipsPositionScale );
                    tracks.push( new THREE.VectorKeyframeTrack( `${ vrmNodeName }.${ propertyName }`, track.times, value ) );
                }
            }
        } );
        return new THREE.AnimationClip( 'vrmAnimation', clip.duration, tracks );
    } );
}

const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setClearColor( 0x000000, 0 );
document.body.appendChild( renderer.domElement );

const camera = new THREE.PerspectiveCamera( 30.0, window.innerWidth / window.innerHeight, 0.1, 20.0 );
camera.position.set( 0.0, 1.0, 5.0 );

const controls = new OrbitControls( camera, renderer.domElement );
controls.screenSpacePanning = true;
controls.target.set( 0.0, 1.0, 0.0 );
controls.update();
controls.enabled = false;

const scene = new THREE.Scene();

// Transparent background for embedding
scene.background = null;

const light = new THREE.DirectionalLight( 0xffffff, Math.PI );
light.position.set( 1.0, 1.0, 1.0 ).normalize();
scene.add( light );

const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

let currentVrm = undefined;
let currentAnimationUrl = undefined;
let currentMixer = undefined;
let currentAction = undefined;
let lastUsedAnimationIndex = -1;
let blinkInterval = undefined;
let bgmAudio = undefined;
let bgmEnabled = true;
let __bgmBaseVol = 0.25;
let __bgmDuckVol = 0.08; // volume while speaking
let smileController = undefined;
let ambientController = undefined;
let postLoadBlurTimerId = undefined;

const helperRoot = new THREE.Group();
helperRoot.renderOrder = 10000;
helperRoot.visible = false;
scene.add( helperRoot );

// Loading UI helpers
function setModelLoading(isLoading) {
    try {
        const overlay = document.getElementById('loadingOverlay');
        const canvas = renderer?.domElement;
        if (!overlay || !canvas) return;
        overlay.style.display = isLoading ? 'flex' : 'none';
        // Manage blur on canvas: blur while loading, remove when loaded
        if (isLoading) {
            if (postLoadBlurTimerId) { clearTimeout(postLoadBlurTimerId); postLoadBlurTimerId = undefined; }
            canvas.classList.add('loading-blur');
        } else {
            if (postLoadBlurTimerId) { clearTimeout(postLoadBlurTimerId); postLoadBlurTimerId = undefined; }
            try { canvas.classList.remove('loading-blur'); } catch {}
            try { overlayHiddenAt = performance.now(); } catch {}
            try {
                if (currentAnimationUrl) {
                    const name = safeFileNameFromUrl(currentAnimationUrl) || 'Animation';
                    loadFBX(currentAnimationUrl, name, 0.5);
                } else if (lastUsedAnimationIndex === -1) {
                    const idleName = getDefaultIdleAnimation();
                    if (idleName) {
                        getAnimationURL(idleName).then(u => { if (u) loadFBX(u, idleName, 0.5); });
                    }
                } else if (window.loadNextAnimation) {
                    window.loadNextAnimation();
                }
            } catch {}
        }
        const text = document.getElementById('loadingText');
        if (!isLoading && text) text.textContent = 'Loading... 0%';
    } catch {}
}
function updateLoadingProgress(percent) {
    try {
        const text = document.getElementById('loadingText');
        if (text) text.textContent = `Loading... ${Math.max(0, Math.min(100, percent|0))}%`;
        if ((percent|0) >= 100 && progress100At == null) { try { progress100At = performance.now(); notifyInitialReadyIfDone(); } catch {} }
    } catch {}
}

function getRandomItem(array) {
    if (!array || array.length === 0) return null;
    return array[Math.floor(Math.random() * array.length)];
}

function getNextAnimation() {
    if (!fbxFiles || fbxFiles.length === 0) return null;
    let attempts = 0;
    let randomIndex;
    let randomFBX;
    do {
        randomIndex = Math.floor(Math.random() * fbxFiles.length);
        randomFBX = fbxFiles[randomIndex];
        attempts++;
    } while (randomIndex === lastUsedAnimationIndex && attempts < 10 && fbxFiles.length > 1);
    lastUsedAnimationIndex = randomIndex;
    return randomFBX;
}

// Calm default animation for first-time auto-play
function getDefaultIdleAnimation() {
    if (!fbxFiles || fbxFiles.length === 0) return null;
    const priorities = [
        /idle/i,
        /stand/i,
        /greet|greeting|hello|wave/i,
        /hand\s*raising/i,
        /talk/i
    ];
    for (const p of priorities) {
        const match = fbxFiles.find(name => p.test(name));
        if (match) return match;
    }
    return null;
}

function updateFileDisplay(modelName, animationName) {
    document.getElementById('currentModel').textContent = modelName || 'None';
    document.getElementById('currentAnimation').textContent = animationName || 'None';
}

let expressionsFolder = null;
let expressionParams = {};

const commonExpressions = [
    'blink','blinkLeft','blinkRight','wink','winkLeft','winkRight',
    'aa','ih','ou','ee','oh','teethOpen',
    'lookUp','lookDown','lookLeft','lookRight',
    'happy','relaxed','surprised','angry','sad','fun','lowered','raised','joy'
];

function setupBlendshapes(vrm) {
    if (!vrm || !vrm.expressionManager) {
        return;
    }
    if (expressionsFolder) {
        gui.removeFolder(expressionsFolder);
        expressionsFolder = null;
        expressionParams = {};
    }
    expressionsFolder = gui.addFolder('Expressions');
    let validExpressions = [];
    if (vrm.expressionManager.expressionMap) {
        validExpressions = Object.keys(vrm.expressionManager.expressionMap);
    } else if (vrm.expressionManager._expressionMap) {
        validExpressions = Object.keys(vrm.expressionManager._expressionMap);
    } else if (vrm.expressionManager.expressions) {
        validExpressions = Object.keys(vrm.expressionManager.expressions);
    } else if (Array.isArray(vrm.expressionManager.blinkExpressionNames)) {
        validExpressions = [
            ...vrm.expressionManager.blinkExpressionNames,
            ...(vrm.expressionManager.mouthExpressionNames || []),
            ...(vrm.expressionManager.lookAtExpressionNames || [])
        ];
    } else {
        validExpressions = commonExpressions;
    }
    for (const name of validExpressions) {
        if (Object.prototype.hasOwnProperty.call(expressionParams, name)) continue;
        expressionParams[name] = 0.0;
        try {
            const controller = expressionsFolder.add(expressionParams, name, 0.0, 1.0, 0.01);
            controller.onChange((value) => {
                if (vrm && vrm.expressionManager) {
                    try {
                        vrm.expressionManager.setValue(name, value);
                    } catch {}
                }
            });
        } catch {
            delete expressionParams[name];
        }
    }
    if (Object.keys(expressionParams).length > 0) {
        expressionsFolder.open();
    }
}

function startRandomBlinking(vrm) {
    if (!vrm || !vrm.expressionManager) return;
    stopRandomBlinking();
    // Store reference to current vrm for this instance
    const targetVrm = vrm;
    console.log('Starting blinking for VRM:', vrm);
    const blinkExpressions = ['blink', 'blinkLeft', 'blinkRight', 'Blink', 'eyesClosed'];
    let blinkAnimationFrame = null;
    let blinkStartTime = 0;
    let isBlinking = false;
    let currentBlinkValue = 0.0;
    const animateBlink = (timestamp) => {
        if (!isBlinking) {
            blinkAnimationFrame = requestAnimationFrame(animateBlink);
            return;
        }
        const elapsed = (timestamp - blinkStartTime) / 1000;
        const blinkDuration = 0.15;
        if (elapsed < blinkDuration) {
            let blinkProgress;
            if (elapsed < blinkDuration / 2) {
                blinkProgress = 0.5 * (1 - Math.cos(Math.PI * elapsed / (blinkDuration / 2)));
            } else {
                const openElapsed = elapsed - blinkDuration / 2;
                blinkProgress = 0.5 * (1 + Math.cos(Math.PI * openElapsed / (blinkDuration / 2)));
            }
            currentBlinkValue = Math.min(1.0, blinkProgress);
            if (targetVrm && targetVrm.expressionManager) {
                for (const blinkName of blinkExpressions) {
                    try { targetVrm.expressionManager.setValue(blinkName, currentBlinkValue); } catch {}
                }
            }
            blinkAnimationFrame = requestAnimationFrame(animateBlink);
        } else {
            isBlinking = false;
            currentBlinkValue = 0.0;
            if (targetVrm && targetVrm.expressionManager) {
                for (const blinkName of blinkExpressions) {
                    try { targetVrm.expressionManager.setValue(blinkName, 0.0); } catch {}
                }
            }
        }
    };
    blinkAnimationFrame = requestAnimationFrame(animateBlink);
    const performBlink = () => {
        if (!targetVrm || !targetVrm.expressionManager || isBlinking) return;
        isBlinking = true;
        blinkStartTime = performance.now();
    };
    let scheduleTimeout = null;
    const scheduleBlink = () => {
        // While speaking, blink more often (1–2s). Otherwise 1–3s.
        const speaking = performance.now() < __speechActiveUntil;
        const randomInterval = speaking ? (Math.random() * 1 + 1) * 1000 : (Math.random() * 2 + 1) * 1000;
        scheduleTimeout = setTimeout(() => { 
            performBlink(); 
            scheduleBlink(); 
        }, randomInterval);
    };
    scheduleBlink();
    blinkInterval = { 
        cancel: () => {
            cancelAnimationFrame(blinkAnimationFrame);
            if (scheduleTimeout) {
                clearTimeout(scheduleTimeout);
                scheduleTimeout = null;
            }
        }
    };
}

function stopRandomBlinking() {
    if (blinkInterval) {
        if (blinkInterval.cancel) { blinkInterval.cancel(); }
        blinkInterval = undefined;
    }
}

// Periodic smiling similar to blinking
function startRandomSmiling(vrm) {
    if (!vrm || !vrm.expressionManager) return;
    stopRandomSmiling();
    const targetVrm = vrm;
    console.log('Starting smiling for VRM:', vrm);
    const smileExpressions = ['happy','joy','Joy','smile','Smile','fun','relaxed','smileOpen'];
    let smileAnimationFrame = null;
    let smileStartTime = 0;
    let isSmiling = false;
    let phase = 'in'; // 'in' -> 'hold' -> 'out'
    const durations = { in: 0.3, hold: 0.25, out: 0.3 };
    const maxSmile = 0.22; // subtle peak intensity

    const setSmileValue = (v) => {
        if (targetVrm && targetVrm.expressionManager) {
            for (const n of smileExpressions) {
                try { targetVrm.expressionManager.setValue(n, v); } catch {}
            }
        }
    };

    const animateSmile = (timestamp) => {
        if (!isSmiling) {
            smileAnimationFrame = requestAnimationFrame(animateSmile);
            return;
        }
        const t = (timestamp - smileStartTime) / 1000;
        let value = 0.0;
        if (phase === 'in') {
            const p = Math.min(1, t / durations.in);
            value = 0.5 * (1 - Math.cos(Math.PI * p)); // ease-in
            if (p >= 1) { phase = 'hold'; smileStartTime = timestamp; }
        } else if (phase === 'hold') {
            value = 1.0;
            if (t >= durations.hold) { phase = 'out'; smileStartTime = timestamp; }
        } else {
            const p = Math.min(1, t / durations.out);
            value = 1 - 0.5 * (1 - Math.cos(Math.PI * p)); // ease-out
            if (p >= 1) { isSmiling = false; value = 0.0; }
        }
        const clamped = Math.max(0, Math.min(1, value));
        setSmileValue(maxSmile * clamped);
        smileAnimationFrame = requestAnimationFrame(animateSmile);
    };
    smileAnimationFrame = requestAnimationFrame(animateSmile);

    const performSmile = () => {
        if (!targetVrm || !targetVrm.expressionManager || isSmiling) return;
        isSmiling = true;
        phase = 'in';
        smileStartTime = performance.now();
    };

    let smileScheduleTimeout = null;
    const scheduleSmile = () => {
        const intervalMs = (Math.random() * 5 + 5) * 1000; // 5-10s
        smileScheduleTimeout = setTimeout(() => { 
            performSmile(); 
            scheduleSmile(); 
        }, intervalMs);
    };
    scheduleSmile();
    smileController = { 
        cancel: () => {
            cancelAnimationFrame(smileAnimationFrame);
            if (smileScheduleTimeout) {
                clearTimeout(smileScheduleTimeout);
                smileScheduleTimeout = null;
            }
        }, 
        clear: () => setSmileValue(0.0) 
    };
}

function stopRandomSmiling() {
    if (smileController) {
        try { if (smileController.clear) smileController.clear(); } catch {}
        try { if (smileController.cancel) smileController.cancel(); } catch {}
        smileController = undefined;
    }
}

// Ambient micro-expressions: randomly trigger subtle positive expressions with random intensity/duration
function startAmbientMicroExpressions(vrm) {
    if (!vrm || !vrm.expressionManager) return;
    stopAmbientMicroExpressions();
    const targetVrm = vrm;
    console.log('Starting ambient expressions for VRM:', vrm);
    const positiveCandidates = [
        'happy','joy','fun','relaxed','lowered','raised', // generic positive/eyebrow
        'ee','oh','aa','ih','ou' // subtle mouth shapes (speech-like micro-movements)
    ];

    let raf = null;
    let active = false;
    let startTime = 0;
    let duration = 0.6;
    let maxIntensity = 0.15;
    let targetNames = [];
    let phase = 'in';

    const setValues = (v) => {
        if (targetVrm && targetVrm.expressionManager) {
            for (const n of targetNames) {
                try { targetVrm.expressionManager.setValue(n, v); } catch {}
            }
        }
    };

    const chooseTargets = () => {
        // Choose 1–2 expressions randomly
        const count = Math.random() < 0.65 ? 1 : 2;
        const picks = [];
        const pool = positiveCandidates.slice();
        while (picks.length < count && pool.length > 0) {
            const i = (Math.random() * pool.length) | 0;
            picks.push(pool.splice(i, 1)[0]);
        }
        return picks;
    };

    const animate = (ts) => {
        if (!active) { raf = requestAnimationFrame(animate); return; }
        const t = (ts - startTime) / 1000;
        let value = 0.0;
        const inDur = duration * 0.35;
        const holdDur = duration * 0.3;
        const outDur = duration * 0.35;
        if (phase === 'in') {
            const p = Math.min(1, t / inDur);
            value = 0.5 * (1 - Math.cos(Math.PI * p));
            if (p >= 1) { phase = 'hold'; startTime = ts; }
        } else if (phase === 'hold') {
            value = 1.0;
            if (t >= holdDur) { phase = 'out'; startTime = ts; }
        } else {
            const p = Math.min(1, t / outDur);
            value = 1 - 0.5 * (1 - Math.cos(Math.PI * p));
            if (p >= 1) { active = false; value = 0.0; }
        }
        setValues(maxIntensity * Math.max(0, Math.min(1, value)));
        raf = requestAnimationFrame(animate);
    };
    raf = requestAnimationFrame(animate);

    const trigger = () => {
        if (!targetVrm || !targetVrm.expressionManager || active) return;
        // Randomize parameters per event
        targetNames = chooseTargets();
        maxIntensity = 0.07 + Math.random() * 0.13; // 0.07–0.20
        duration = 0.5 + Math.random() * 0.7; // 0.5–1.2s
        phase = 'in';
        active = true;
        startTime = performance.now();
    };

    let ambientScheduleTimeout = null;
    const schedule = () => {
        const interval = (Math.random() * 4 + 3.5) * 1000; // 3.5–7.5s
        ambientScheduleTimeout = setTimeout(() => { 
            trigger(); 
            schedule(); 
        }, interval);
    };
    schedule();
    ambientController = {
        cancel: () => {
            cancelAnimationFrame(raf);
            if (ambientScheduleTimeout) {
                clearTimeout(ambientScheduleTimeout);
                ambientScheduleTimeout = null;
            }
        },
        clear: () => setValues(0.0)
    };
}

function stopAmbientMicroExpressions() {
    if (ambientController) {
        try { if (ambientController.clear) ambientController.clear(); } catch {}
        try { if (ambientController.cancel) ambientController.cancel(); } catch {}
        ambientController = undefined;
    }
}

function loadVRM( modelUrl, modelName, animationToLoad = null ) {
    const loader = new GLTFLoader();
    loader.crossOrigin = 'anonymous';
    helperRoot.clear();
    loader.register( ( parser ) => new VRMLoaderPlugin( parser, { helperRoot: helperRoot, autoUpdateHumanBones: true } ) );
    // show loading overlay
    setModelLoading(true);
    loader.load(
        modelUrl,
        ( gltf ) => {
            const vrm = gltf.userData.vrm;
            VRMUtils.removeUnnecessaryVertices( gltf.scene );
            VRMUtils.combineSkeletons( gltf.scene );
            // Don't combine morphs - it interferes with expression blendshapes
            // VRMUtils.combineMorphs( vrm );
            if ( currentVrm ) {
                stopRandomBlinking();
                stopRandomSmiling();
                stopAmbientMicroExpressions();
                scene.remove( currentVrm.scene );
                VRMUtils.deepDispose( currentVrm.scene );
            }
            currentVrm = vrm;
            scene.add( vrm.scene );
			currentMixer = new THREE.AnimationMixer( currentVrm.scene );
			// Clear any previous action from old mixer to avoid cross-fading across mixers
			currentAction = undefined;
            vrm.scene.traverse( ( obj ) => { obj.frustumCulled = false; } );
            VRMUtils.rotateVRM0( vrm );
            updateFileDisplay(modelName, document.getElementById('currentAnimation').textContent);
            setupBlendshapes(vrm);
            
            // Start expressions after animation is applied
            const startExpressions = () => {
                startRandomBlinking(vrm);
                startRandomSmiling(vrm);
                startAmbientMicroExpressions(vrm);
            };
            
            if ( animationToLoad ) {
				// Defer auto-play until post-load blur finishes; only set the selected animation name
				(async () => {
					try {
						const animName = safeFileNameFromUrl(animationToLoad);
						currentAnimationUrl = animationToLoad;
						updateFileDisplay(modelName, animName || 'Animation');
					} catch {}
				})();
            } else {
                // No animation to load, start expressions after a short delay
                setTimeout(startExpressions, 500);
            }
            // Notify Swift that model is loaded and scene attached
            try { window.webkit?.messageHandlers?.loading?.postMessage('modelLoaded'); } catch {}
            // hide loading overlay
            setModelLoading(false);
        },
        ( progress ) => {
            const percent = progress.total ? (100.0 * ( progress.loaded / progress.total )) : 0;
            updateFileDisplay(`Loading... ${percent.toFixed(0)}%`, document.getElementById('currentAnimation').textContent);
            updateLoadingProgress(percent);
        },
        ( error ) => {
            /* error loading VRM */
            updateFileDisplay('Error loading model', document.getElementById('currentAnimation').textContent);
            setModelLoading(false);
        },
    );
}

function loadFBX( animationUrl, animationName, crossFadeDuration = 0.5 ) {
    currentAnimationUrl = animationUrl;
    if ( !currentMixer || !currentVrm ) {
        /* please load a VRM model first */
        return;
    }
    updateFileDisplay(document.getElementById('currentModel').textContent, `Loading ${animationName}...`);
    loadHumanoidAnimation( animationUrl, currentVrm )
        .then( ( clip ) => {
            const newAction = currentMixer.clipAction( clip );
            newAction.reset();
            if ( currentAction && currentAction !== newAction ) {
                newAction.play();
                currentAction.crossFadeTo( newAction, crossFadeDuration, true );
            } else {
                newAction.play();
            }
            currentAction = newAction;
            updateFileDisplay(document.getElementById('currentModel').textContent, animationName);
            if (!initialAnimationApplied) { initialAnimationApplied = true; notifyInitialReadyIfDone(); }
            
            // Start expressions after animation has started playing
            if (currentVrm) {
                setTimeout(() => {
                    // Only start if not already running
                    if (!blinkInterval) {
                        startRandomBlinking(currentVrm);
                        startRandomSmiling(currentVrm);
                        startAmbientMicroExpressions(currentVrm);
                    }
                }, 200);
            }
        })
        .catch( ( error ) => {
            /* error loading animation */
            updateFileDisplay(document.getElementById('currentModel').textContent, 'Error: ' + error.message);
        });
}

window.loadRandomFiles = async function() {
    const randomVRM = getRandomItem(vrmFiles);
    const randomFBX = getNextAnimation();
    if (randomVRM && randomFBX) {
        const vrmUrl = await getModelURL(randomVRM);
        // Do not start animation immediately; it will auto-play after post-load blur
        loadVRM(vrmUrl, randomVRM);
        // Start background preloading excluding current selections
        startBackgroundPreloading(randomVRM, randomFBX);
    } else if (randomVRM) {
        const vrmUrl = await getModelURL(randomVRM);
        loadVRM(vrmUrl, randomVRM);
        startBackgroundPreloading(randomVRM, null);
    }
}

window.loadNextAnimation = async function() {
    if (!currentVrm || !currentMixer) {
        alert('Please load a VRM model first');
        return;
    }
    const nextFBX = getNextAnimation();
    if (nextFBX) {
        const fbxUrl = await getAnimationURL(nextFBX);
        const btn = document.getElementById('nextAnimBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Loading...';
        btn.disabled = true;
        loadFBX(fbxUrl, nextFBX, 0.8);
        setTimeout(() => {
            btn.textContent = originalText;
            btn.disabled = false;
        }, 1500);
    }
}

// Background music controls
window.initBgm = function() {
    try {
        if (bgmAudio) return;
        bgmAudio = new Audio(BGM_URL);
        bgmAudio.loop = true;
        bgmAudio.volume = __bgmBaseVol;
        try { bgmAudio.playsInline = true; } catch {}
        try { bgmAudio.setAttribute && bgmAudio.setAttribute('playsinline', ''); } catch {}
        bgmAudio.muted = false;
        bgmAudio.play().then(() => { bgmEnabled = true; }).catch(() => {
            // Fallback: resume on first user interaction
            const resume = () => {
                try { bgmAudio.muted = false; bgmAudio.play().catch(() => {}); bgmEnabled = true; } catch {}
                window.removeEventListener('touchstart', resume, { capture: true });
                window.removeEventListener('touchend', resume, { capture: true });
                window.removeEventListener('pointerdown', resume, { capture: true });
                window.removeEventListener('click', resume, { capture: true });
            };
            window.addEventListener('touchstart', resume, { once: true, capture: true });
            window.addEventListener('touchend', resume, { once: true, capture: true });
            window.addEventListener('pointerdown', resume, { once: true, capture: true });
            window.addEventListener('click', resume, { once: true, capture: true });
        });
    } catch {}
}
window.toggleBgm = function() {
    try {
        if (!bgmAudio) { window.initBgm(); }
        if (!bgmAudio) return false;
        if (bgmAudio.paused) {
            bgmAudio.muted = false;
            bgmAudio.play().catch(() => {});
            bgmEnabled = true;
        } else {
            bgmAudio.pause();
            bgmEnabled = false;
        }
        return !bgmAudio.paused;
    } catch { return false; }
}
window.setBgm = function(enabled) {
    try {
        if (!bgmAudio) { window.initBgm(); }
        if (!bgmAudio) return false;
        if (enabled) {
            bgmAudio.muted = false;
            bgmAudio.play().catch(() => {});
            bgmEnabled = true;
        } else {
            bgmAudio.pause();
            bgmEnabled = false;
        }
        return enabled;
    } catch { return false; }
}
// Optional: adjust base/ducking volumes at runtime
window.setBgmVolumes = function(baseVol = 0.25, duckVol = 0.08) {
    try {
        __bgmBaseVol = Math.max(0, Math.min(1, Number(baseVol) || 0.25));
        __bgmDuckVol = Math.max(0, Math.min(1, Number(duckVol) || 0.08));
        if (bgmAudio && !bgmAudio.paused) {
            bgmAudio.volume = __bgmBaseVol;
        }
    } catch {}
}
window.isBgmPlaying = function() {
    try { return !!bgmAudio && !bgmAudio.paused; } catch { return false; }
}

// Load a specific VRM model by file name (exposed to SwiftUI)
window.loadModelByName = async function(modelName) {
    try {
        const vrmUrl = await getModelURL(modelName);
        if (!vrmUrl) return;
        loadVRM(vrmUrl, modelName);
        // Optionally kick off background preloading excluding the current selection
        startBackgroundPreloading(modelName, null);
    } catch (e) {
        /* error loading model by name */
    }
}

// Load a VRM model by direct URL (optional display name)
window.loadModelByURL = async function(url, name = 'Remote Model') {
    try {
        if (!url) return;
        loadVRM(url, name);
        startBackgroundPreloading(null, null);
    } catch (e) {
        /* error loading model by URL */
    }
}

window.addEventListener('DOMContentLoaded', async function() {
    // Apply initial background from native if provided
    try {
        if (typeof window.initialBackgroundUrl === 'string' && window.initialBackgroundUrl.trim().length) {
            const url = window.initialBackgroundUrl.trim();
            document.body.style.backgroundImage = `url('${url}')`;
            // Mark ready since background is applied synchronously
            if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
        }
    } catch {}
    // Allow native (Swift) to preselect a model by setting window.nativeSelectedModelName or nativeSelectedModelURL
    const nativeName = (typeof window.nativeSelectedModelName === 'string' && window.nativeSelectedModelName.trim().length) ? window.nativeSelectedModelName.trim() : null;
    const nativeURL = (typeof window.nativeSelectedModelURL === 'string' && window.nativeSelectedModelURL.trim().length) ? window.nativeSelectedModelURL.trim() : null;
    if (nativeURL) {
        loadModelByURL(nativeURL, nativeName || 'Remote Model');
    } else {
        const modelToLoad = nativeName || '0001_01 2.vrm';
        const vrmUrl = await getModelURL(modelToLoad);
        loadVRM(vrmUrl, modelToLoad);
    }
    startBackgroundPreloading(modelToLoad, null);
    // Initialize background music on homepage access
    try { window.initBgm(); } catch {}
});

const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame( animate );
    const deltaTime = clock.getDelta();
    if ( currentMixer ) { currentMixer.update( deltaTime ); }
    if ( currentVrm ) { currentVrm.update( deltaTime ); }
    applyBgmDucking();
    renderer.render( scene, camera );
}
animate();

const gui = new GUI();
const params = { timeScale: 1.0, showHelpers: false };
gui.add( params, 'timeScale', 0.0, 2.0, 0.001 ).onChange( ( value ) => {
    if ( currentMixer ) { currentMixer.timeScale = value; }
} );
gui.add( params, 'showHelpers' ).onChange( ( value ) => { helperRoot.visible = value; } );

window.addEventListener( 'dragover', function ( event ) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
} );
window.addEventListener( 'drop', function ( event ) {
    event.preventDefault();
    const files = event.dataTransfer.files;
    if ( ! files ) return;
    const file = files[ 0 ];
    if ( ! file ) return;
    const fileType = file.name.split( '.' ).pop().toLowerCase();
    const blob = new Blob( [ file ], { type: 'application/octet-stream' } );
    const url = URL.createObjectURL( blob );
    if ( fileType === 'fbx' ) {
        currentAnimationUrl = url;
        if (currentVrm && currentMixer) {
            loadFBX( url, file.name );
        } else {
            alert('Please load a VRM model first before loading animation');
        }
    } else if ( fileType === 'vrm' || fileType === 'glb' || fileType === 'gltf' ) {
        loadVRM( url, file.name );
    } else {
        alert('Unsupported file type. Please drop a .vrm, .glb, .gltf, or .fbx file');
    }
} );

window.addEventListener( 'resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
} );

// Expose handlers for native SwiftUI buttons
(() => {
    // Dynamically fetched background rooms
    let roomList = [];
    let bgIndex = -1;
    // Guard to sequence background transitions and avoid flicker/race
    let bgTransitionId = 0;

    async function fetchRooms() {
        try {
            const res = await fetch('https://n8n8n.top/webhook/rooms', { mode: 'cors' });
            const data = await res.json();
            if (Array.isArray(data)) {
                roomList = data.filter(r => r && (r.image || r.thumbnail));
                if (roomList.length > 0 && bgIndex < 0) {
                    // Do not auto-apply a new background on initial load; keep existing
                    // Just initialize index and mark background as ready for gating
                    bgIndex = 0;
                    if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                }
            }
        } catch {
            // keep current background on error; treat as ready
            if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
        }
    }

    function smoothSetBackground(url) {
        try {
            const overlay = document.getElementById('bgFadeOverlay');
            if (!overlay || !url) { document.body.style.backgroundImage = `url('${url}')`; return; }
            const myId = ++bgTransitionId;
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                if (myId !== bgTransitionId) return; // superseded
                overlay.style.transition = 'none';
                overlay.style.backgroundImage = `url('${url}')`;
                overlay.style.opacity = '0';
                void overlay.offsetWidth; // reflow
                overlay.style.transition = 'opacity 400ms ease';
                overlay.style.opacity = '1';
                setTimeout(() => {
                    if (myId !== bgTransitionId) return;
                    document.body.style.backgroundImage = `url('${url}')`;
                    overlay.style.opacity = '0';
                    if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                }, 420);
            };
            img.onerror = () => {
                if (myId !== bgTransitionId) return;
                document.body.style.backgroundImage = `url('${url}')`;
                if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
            };
            img.src = url;
        } catch {}
    }

    // Public controls
    window.nextBackground = function() {
        try {
            if (!roomList.length) { fetchRooms(); return; }
            bgIndex = (bgIndex + 1) % roomList.length;
            const url = roomList[bgIndex].image || roomList[bgIndex].thumbnail;
            if (url) smoothSetBackground(url);
        } catch {}
    };
    window.prevBackground = function() {
        try {
            if (!roomList.length) { fetchRooms(); return; }
            bgIndex = (bgIndex - 1 + roomList.length) % roomList.length;
            const url = roomList[bgIndex].image || roomList[bgIndex].thumbnail;
            if (url) smoothSetBackground(url);
        } catch {}
    };
    window.setBackgroundImage = function(url) {
        try {
            if (url) smoothSetBackground(url);
            // Try to align bgIndex with the provided url if it exists in list
            const i = roomList.findIndex(r => r.image === url || r.thumbnail === url);
            if (i >= 0) bgIndex = i;
        } catch {}
    };

    // Expose current room name to native
    window.getCurrentRoomName = function() {
        try {
            if (!roomList.length || bgIndex < 0) return '';
            return roomList[bgIndex]?.name || '';
        } catch { return ''; }
    };

    // Initial fetch
    fetchRooms();
    window.triggerDance = function() {
        try { window.loadNextAnimation && window.loadNextAnimation(); } catch {}
    };
    window.triggerLove = function() {
        if (!currentVrm || !currentVrm.expressionManager) return;
        const names = ['happy','joy','fun','relaxed'];
        let t0 = performance.now();
        const dur = 0.9;
        const maxV = 0.35;
        const setVal = (v) => { for (const n of names) { try { currentVrm.expressionManager.setValue(n, v); } catch {} } };
        const step = (ts) => {
            const t = (ts - t0) / 1000;
            if (t <= dur) {
                const p = t / dur;
                const v = p < 0.5 ? (maxV * (0.5 * (1 - Math.cos(Math.PI * (p/0.5))))) : (maxV * (1 - 0.5 * (1 - Math.cos(Math.PI * ((p-0.5)/0.5)))));
                setVal(Math.max(0, Math.min(maxV, v)));
                requestAnimationFrame(step);
            } else {
                setVal(0.0);
            }
        };
        requestAnimationFrame(step);
    };
})();

// Parallax application: move background subtly with device tilt
window.applyParallax = (dx, dy) => {
    try {
        const overlay = document.getElementById('bgFadeOverlay');
        const x = Math.max(-100, Math.min(100, Number(dx) || 0));
        const y = 0; // lock Y parallax
        // Translate overlay for smooth GPU movement
        if (overlay) {
            overlay.style.transform = `translate(${x * 0.9}px, ${y}px)`;
        }
        // Also nudge body background position as a fallback
        document.body.style.backgroundPosition = `calc(50% + ${x * 0.5}px) 50%`;
    } catch {}
};

    // Lipsync: set mouth openness [0..1]; damped smoothing
    let __mouthLerp = 0;
    let __speechActiveUntil = 0; // ms timestamp while speech is considered active
    window.setMouthOpen = (v) => {
        try {
            // Amplify and bias for stronger lipsync
            const raw = Math.max(0, Math.min(1, Number(v) || 0));
            // Gain and soft gamma curve make quiet sounds visible and loud sounds pop
            const gain = 3.0;            // stronger amplification
            const gamma = 0.65;          // stronger curve
            const biased = Math.pow(Math.min(1, raw * gain), gamma);
            // Much faster response for more realistic lipsync
            __mouthLerp = 0.15 * __mouthLerp + 0.85 * biased;
            // Mark speech as active for blink scheduling
            if (raw > 0.02) { __speechActiveUntil = performance.now() + 900; }
            if (currentVrm && currentVrm.expressionManager) {
            // Allow a bigger apparent opening, then clamp
            const main = Math.max(0, Math.min(1, __mouthLerp * 1.35));
                // Emphasize "aa" most, others slightly lower to avoid flat mouth shapes
                const map = [
                    ['aa', main],
                    ['ee', main * 0.8],
                    ['ih', main * 0.75],
                    ['oh', Math.min(1, main * 1.1)],
                    ['ou', Math.min(1, main * 1.05)],
                    ['teethOpen', main * 0.6],
                ];
                for (const [n, val] of map) {
                    try { currentVrm.expressionManager.setValue(n, val); } catch {}
                }
            }
            // Also apply BG music ducking here (instant target change, smoothed in per-frame loop)
        } catch {}
    };

    function applyBgmDucking() {
        try {
            if (!bgmAudio) return;
            const speaking = performance.now() < __speechActiveUntil;
            const target = speaking ? __bgmDuckVol : __bgmBaseVol;
            // smooth toward target
            const next = bgmAudio.volume + (target - bgmAudio.volume) * 0.15;
            bgmAudio.volume = Math.max(0, Math.min(1, next));
        } catch {}
    }
        </script>
    </body>
</html>
